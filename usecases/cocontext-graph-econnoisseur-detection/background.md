# 背景介绍

### 前言

通过前面到几个案例，我们基本上熟悉了 TigerGraph 的 Web 界面，GraphStudio 的基本使用，以及 GSQL 查询语句的写法。在我们所面临的实际问题中，应该更多去思考，如何针对不同的场景，去设计适合场景的图模型。

这一次我们使用的数据，来源于原始风控日志。什么是风控日志呢？一个线上电商系统，在一些关键业务流程上，会接入风控系统，用来判断当前用户所做的操作，是否具备较高风险。风控日志则是风控系统接收响应风控请求的日志，风控日志中每一条数据，即一个风控请求，也可以理解成用户产生了一条风控事件。

一个风控事件至少包含以下几个要素:

* 用户名
* 时间
* 事件类型
* 事件发生的环境 \( Context，或称上下文\)，例如 IP，设备号，地理位置
* 其他补充信息

常见的事件类型有，注册、登入、打卡签到、下单、支付等。根据风控系统的覆盖范围，一些营销活动也会接入风控系统，比如前面所提到的**邀请注册**，此时，邀请人和被邀请人就会计入到该事件的补充信息当中。

```javascript
{"account": "u1", "time": "2020-03-01 09:00:01", "event_type": "login", "ip": "1.1.1.1"}
{"account": "u1", "time": "2020-03-01 09:00:30", "event_type": "order", "ip": "1.1.1.1"}
{"account": "u1", "time": "2020-03-01 09:00:35", "event_type": "pay", "ip": "1.1.1.1"}
{"account": "u2", "time": "2020-03-01 09:00:01", "event_type": "login", "ip": "2.2.2.2"}
{"account": "u2", "time": "2020-03-01 09:00:02", "event_type": "login", "ip": "2.2.2.2"}
{"account": "u2", "time": "2020-03-01 09:00:03", "event_type": "login", "ip": "2.2.2.2"}
{"account": "u2", "time": "2020-03-01 09:00:04", "event_type": "login", "ip": "2.2.2.2"}
```

风控系统接收到业务系统的一条风控事件后，会返回给业务系统对当前风控事件的风险判断，通常是一个风险分值，业务系统结合该风险分值，决定是否对用户当前的操作进行拦截。拦截的方式可能是，拒绝操作，弹滑动验证码，弹短信验证码等。

一般来说，风控系统的识别引擎，由 **统计规则 + 机器学习模型** 构成。譬如同一个账户在1分钟内登录超过一定次数，那么他可能在暴力破解密码，一个 IP 地址一天下了大量订单，那他可能是一个代购。机器学习模型可能使用人工标注或者外部购买的名单，基于人工抽取的特征，进行模型训练，本质上相当于一系列复杂规则的组合。

本案例依然从团伙检测角度出发，对比之前的案例，会介绍另外一种建边的思路，并提供一些实现实时数据导入，实时团伙检测的方法。

### Co-Context Edge 共现关系边

之前案例中我们提到通过在**邀请关系**子图上寻找 Connected Component 的方式来定位黑产团伙。这是因为邀请关系是一种明确的，强力的关系。但在原始风控事件中，可以提炼的关系还有很多，比如 IP 地址，设备信息等。

![&#x56FE;&#x4E2D;&#x6709;&#x591A;&#x79CD;&#x7C7B;&#x578B;&#x8282;&#x70B9;](../../.gitbook/assets/hetergenous-graph.png)

一种思路如上图，可以将同一条日志中的账号，设备，IP关联到一起。但这种设计会有几个明显的问题：

1. 很难处理动态 IP 的情况。一个 IP 地址可能上午被一个黑产团伙使用，下午又被分配给了一个正常用户，带来的后果是，某些 IP 地址，尤其是 3G/4G 上网的地址，**会逐渐形成一个超大的 CC**，这里面要把正常用户与黑产账号区分开，比较困难
2. 在同一个 IP 地址下的不同用户之间的**关系强弱不容易衡量**
3. 写 GSQL 进行节点遍历的时候，比较繁琐，**影响查询效率**

另一个思路是，我们让图中只保留一种类型的节点，比如**账号**，将他们同时出现过的上下文信息，体现在边上。

![&#x56FE;&#x4E2D;&#x53EA;&#x6709;&#x4E00;&#x79CD;&#x7C7B;&#x578B;&#x8282;&#x70B9;](../../.gitbook/assets/homogeneous-graph.png)

这种构图思路，有以下几点好处:

1. 账户与账户之间直接连接，**容易定义关系强弱**，比如使用 2 个账户在同一个 IP 下出现的时间间隔，来定义他们之间的亲密程度
2. 账户与账户之间如果存在多重关系，**方便进行融合**
3. 写 GSQL 进行节点遍历，比较方便，**效率也较高**

### 生成 Co-Context  边的方法

想象一下这么一个场景，有一个 IP 地址，今天上午 9:00 用户 `u1` 使用过，今天下午 15:01 用户 `u2` `u3` `u4` 在同一分钟内使用过，那么 `u2` 与 `u3` `u4` 的关系肯定要比 `u2` 与 `u1` 的关系来的紧密。

因此，针对这种亲密程度和时间相关的边，我们不妨为其添加一个时间上的约束。即，在一个**时间窗口**内，使用了**相同上下文的两个实体之间**，建立一条边。可以将这种边称之为:

> **Time Windowed Co-Context Edge**



